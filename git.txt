‘.gitignore’ 与 ‘.git/info/exclude’
git checkout  -b new_camp 创建并跳转到new_camp新分支名
git rm -- cached proxy.conf.json会在合并后的分支删除该文件，慎用！
	每次要git status查看add的内容啊~~~！
【git reset 文件名】即可撤销git的add操作。
 (use "git restore --staged <file>..." to unstage)
git restore --staged ./java/projects/my-shop/**/target/

撤销操作主要有如下几种

git commit   --amend        撤销上一次提交  并讲暂存区文件重新提交
git checkout -- <file>     拉取暂存区文件 并将其替换成工作区文件
git reset HEAD  -- <file>  拉取最近一次提交到版本库的文件到暂存区  改操作不影响工作区
git log --oneline 查看哈希，然后git reset 哈希 -- <file> 把那个版本放回暂存区，再用git checkout -- <file>把它从暂存拉倒工作区。

find ./ -size +100M
git lfs track "name_of_a_giant_file"
#example:
#git lfs track "fc6_W.csv"
加入track之后可以把想要保存的打文件添加到git上：
git add path_of_a_giant_file
#example:
#git add vgg16_weight/fc6_W.csv



git gc --aggressive 
will cleanup unnecessary files and optimize the local repository.
You can verify that the problem is fixed with the 		
git fsck --full 查看dangling blob   
git ls-tree -r -t commit哈希值 | grep 对象哈希		找出对象对应的文件
git hash-object -w 文件		生成对应哈希

1、从未提交过的文件可以用.gitignore 也就是添加之后从来没有提交（commit）过的文件，可以使用.gitignore忽略该文件 该文件只能作用于未跟踪的文件（Untracked Files），也就是那些从来没有被 git 记录过的文件 比如，忽略log/下的日志文件，可以在.gitignore中写 log/*

2、已经推送（push）过的文件，想从git远程库中删除，并在以后的提交中忽略，但是却还想在本地保留这个文件 执行命令
git rm --cached Xml/config.xml

后面的 Xml/config.xml 是要从远程库中删除的文件的路径，支持通配符* 比如，不小心提交到git上的一些log日志文件，想从远程库删除，可以用这个命令

3、已经推送（push）过的文件，想在以后的提交时忽略此文件，即使本地已经修改过，而且不删除git远程库中相应文件 执行命令 git update-index --assume-unchanged Xml/config.xml 后面的 Xml/config.xml 是要忽略的文件的路径。如果要忽略一个目录，打开 git bash，cd到 目标目录下，执行： git update-index --assume-unchanged $(git ls-files | tr '\n' ' ') 比如有一个配置文件记录数据库的链接信息，每个人的链接信息肯定不一样，但是又要提供一个标准的模板，用来告知如何填写链接信息，那么就需要在git远程库上有一个标准配置文件，然后每个人根据自己的具体情况，修改一份链接信息自用，而且不会将该配置文件提交到库。

恢复跟踪
git update-index --no-assume-unchanged
使用以下命令查看忽略列表
git ls-files -v | grep '^h\ '

有时，我们在gitignore文件添加新的目录，但是没有生效。这是我们可以通过下面的命令，来使得gitignore生效：
git rm -r --cached .
git add .
git commit -m '增加忽略项'
通过命令将 git中的一些缓存清楚，来达到新的gitignore生效的目的。但是这一招可能会造成远程分支在合并后，消失很多文件，因为本地的这些文件被git rm了。


从远程仓库里拉取一条本地不存在的分支时：
git checkout -b 本地分支名 origin/远程分支名

最后一次的提交，对应命令参数 -n 1
最近一次提交所有更改过的文件
对应命令 git log -n 1 --stat
最近一次提交所有更改的细节
对应命令 git log -n 1 -p


git log -p -2	只显示最近的两次提交，显示每次提交所引入的差异。
每次提交的简略统计信息，可以使用 --stat 选项
另一个非常有用的选项是 --pretty。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：
$ git log --pretty=oneline
最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用――因为你知道输出的格式不会随着 Git 的更新而发生改变：
$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : changed the version number
$ git log --pretty=format:"%h %s" --graph


另一个非常有用的过滤器是 -S（俗称“pickaxe”选项，取“用鹤嘴锄在土里捡石头”之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：

$ git log -S function_name


来看一个实际的例子，如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令：
$ git log --pretty="%h - %s" --author='Junio C Hamano' --since="2008-10-01" \
   --before="2008-11-01" --no-merges -- t/

git blame git.txt
查看某行代码由谁写的，在哪个commit中提交的：
其显示格式为：
commit ID | 代码提交作者 | 提交时间 | 代码位于文件中的行数 | 实际代码
这样，我们就可以知道 commit ID 了，然后使用命令：git show commitID 来看

。

git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。
git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add --update的缩写）
git add -A ：是上面两个功能的合集（git add --all的缩写）

git init
git diff readme.txt 
要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；
 git remote add origin git@gitlab.lean.com:zwzq/zw-project.git
直接git pull origin master会找不到，要先git fetch origin在不指定分支时通常默认为master；再git log -p FETCH_HEAD查看刚取回的更新信息；再git pull

关联后，使用命令git push -u origin master第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；

fatal: in unpopulated submodule 'angular/angulardemo01' 因为push从不推送这个目录，而且在这个目录下也不能git add .
解决办法： 在上级目录git rm -rf --cached angulardemo01
然后 git add angulardemo01
但是这样把不需要的也给add了，所以 git reset angular/angulardemo01/node_modules/


client_loop: send disconnect: Connection reset by peers
fatal: the remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
当推送大量数据时（初始推送大型存储库，使用非常大的文件进行更改）可能需要 http.postBuffer 在 git 客户端 （而不是服务器）上设置更高的 设置 ；将 Git 缓冲区大小增加到 repo 的最大单个文件大小：
git config --global http.postBuffer 157286400
或者直接git config remote.origin.url git@github.com:your_username/your_project.git


    用 git clone --depth=1 的好处是限制 clone 的深度，不会下载 Git 协作的历史记录，这样可以大大加快克隆的速度
    depth用于指定克隆深度，为1即表示只克隆最近一次commit
    适合用 git clone --depth=1 的场景：你只是想clone最新版本来使用或学习，而不是参与整个项目的开发工作


git branch                  # 先看一下自己在哪个分支
git checkout -b zhangsan    # 创建一个名为zhangsan的分支
git add 功能A.txt            # 将写好的功能A代码add
git commit -m"功能A第一版"    # 将写好的功能A第一版代码commit
git add 功能A.txt            # 将写好的功能A代码add
git commit -m"功能A第二版"    # 将写好的功能A第二版代码commit

合并为 git commit -am ""

git remote rm origin 先删后改
git remote add origin 
git push origin ...

$ git config user.name	实例
$ git config user.email

$ git config --global user.name "username"	全局
$ git config --global user.email "email"

git checkout master                                        # 回到master分支
git merge --no-ff -m"merge 功能A with --no-ff" zhangsan     # 在master上执行merge操作
git push origin master                                     # 推送到远程

git merge 带上 --no-ff 参数会保存分支的历史信息。如果不加，merge后就看不到分支信息了。
接下来，李四与master进行merge操作，发现可以进行merge，但是没法进行push，原因在1.2节已经说过，就是因为远程的代码有张三push的代码，而李四的本地还没有那些代码，需要先执行一下pull操作

我们可以使用下面的命令，来查看一下历史commit版本
 git log --graph --pretty=oneline --abbrev-commit
然后我们就可以使用git reset --hard commit版本号 进行时光穿梭了



生成并添加第一个ssh key
cd ~/.ssh
ssh-keygen -t rsa -C "youremail@yourcompany.com"

这时可以一路回车，不输入任何字符，将自动生成id_rsa和id_rsa.pub文件。
生成并添加第二个ssh key
$ ssh-keygen -t rsa -C "youremail@gmail.com"

注意，这时不能一路回车，否则邮箱将覆盖上一次生成的ssh key，给这个文件起一个名字， 比如叫 id_rsa_github, 所以相应的也会生成一个 id_rsa_github.pub 文件。

添加私钥｛
若执行ssh-add /path/to/xxx.pem是出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：ssh-agent bash
｝
$ ssh-add ~/.ssh/id_rsa
$ ssh-add ~/.ssh/id_rsa_github

在 ~/.ssh 目录下新建一个config文件
# gitlab
Host gitlab.lean.com		{gitlab具体地址要写清楚}
    HostName gitlab.lean.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa
# github
Host github.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa_github

给github/gitlab上添加ssh key

测试
$ ssh -T git@github.com



ssh-add -D 删除所有管理的密钥

ssh-add -d 删除指定的

ssh-add -l 查看现在增加进去的指纹信息

ssh-add -L 查看现在增加进去的私钥

 

如果重启之后，会发现需要重新load一下ssh-agent

ssh-add -K 将指纹加到钥匙串里面去

ssh-add -A 可以把钥匙串里面的私钥密码，load进ssh-agent
    