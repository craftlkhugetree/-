更改了经济运行分析的需求，basic-setting.ts



递归千万别返回值，直接在递归中通过条件判断赋值，不能返回值。
递归一定要注意循环要加上[i]。
数据不能太大，小数位数不能太多。toFixed(3)保留三位小数，且返回值为字符串。
1. 属性或参数中使用 ？：表示该属性或参数为可选项

2. 属性或参数中使用 ！：表示强制解析（告诉typescript编译器，这里一定有值），常用于vue-decorator中的@Prop

3. 变量后使用 ！：表示类型推断排除null、undefined

function myFunc(maybeString: string | undefined | null) {
  // Type 'string | null | undefined' is not assignable to type 'string'.
  // Type 'undefined' is not assignable to type 'string'. 
  const onlyString: string = maybeString; // Error
  const ignoreUndefinedAndNull: string = maybeString!; // Ok
}


type NumGenerator = () => number;
function myFunc(numGenerator: NumGenerator | undefined) {
  // Object is possibly 'undefined'.(2532)
  // Cannot invoke an object which is possibly 'undefined'.(2722)
  const num1 = numGenerator(); // Error
  const num2 = numGenerator!(); //OK
}

if(a && a.b) { } ====== if(a?.b){ }
但需要注意的是，?. 与 && 运算符行为略有不同，&& 专门用于检测 falsy 值，比如空字符串、0、NaN、null 和 false 等。而 ?. 只会验证对象是否为 null 或 undefined，对于 0 或空字符串来说，并不会出现 “短路”。



  // 取掉名称前面的'-'和空格
  repSig(str) {
    // let sig = [',', '\\.', '\\\\', '/', '<', '>', ';', ':', '"', '{', '}', "'", '；', '。'];
    // for (let i = 0; i < sig.length; i++) {
    //   let p = new RegExp(sig[i], 'g');
    //   str = str.replace(p, '');
    //   // console.log("str:",str)
    // }
    let tmp = [];
    while(str.charAt(0) === '-' || str.charAt(0) === ' '){
      tmp = str.split('');
      tmp.splice(0,1);
      str = tmp.join('');
    }
    return str;
  }