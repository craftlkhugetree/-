顶部搜索按钮：接口获取数据，没有表格，只有树；
已发布、未发布  无效；
责任部门，考核对象  数据结构样式。上传文件无效。
搜索姓名接口加密。
上报计划，之前的数据没有清空，计划被追加。  新增指标无效。
年份自动变为2021。。。400与上级指标年份不同。
要返回修改的依据。
指标管理，编辑窗口隐藏修改依据。  新增getPlanRadio()。   情况上报saveIdx()


赋初值时，是否用null要谨慎，比如radio框的初值必须是null，否则不会清零。但是有些可能要用length或者filter()函数的，如果初值为null，那么就要注意它可能有问题了，或者改为空字符串，或者用||后跟保险值来防止可能出现的无值。

使用  new Date(date);生成日期， date必须是字符串，如果是int型那么得到的是1970年的起始日期。

任何变量一定要赋初值，哪怕是null。否则在html的一些布尔属性，如 [nzShowButton]="flag !== 3" 就会默认不显示，public flag:any;

使用extends，就要考虑到变量统一修改，所以html中的属性值尽量用变量名，而不是实际值。
  // tslint:disable: prefer-for-of
  // tslint:disable: member-ordering
  // tslint:disable: prefer-conditional-expression

同一个form里的nz-input-group，若紧挨着使用搜索后缀，那么第二个的回车会变成第一个输入框里的，点击搜索按钮才会是第二个的。解决办法就是别把它们放在一个form里。

<br/>可以让省略号文本换行，同时:hover省略号文本 overflow:auto;white-space:normal;就可以鼠标移过动态显示省略的文本。要省略必须先设置width。

float:left;能让块级元素同行，但是后面的inline-block会下沉一点，是因为基线的问题，当一个inline-block元素被设置overflow非visible属性值后，其baseline将被强制修改为元素下外边沿。所以修改vertical-align: bottom即可。

视图加载完毕后，可以修改元素属性：
    const tableHeight = this._elementRef.nativeElement.querySelector('#idxCardTable');

 const tree = this._elementRef.nativeElement.querySelector('#idxCardTree');
 this._render.setStyle(tree, 'height' , tableHeight.offsetHeight + 'px');

<nz-select [(ngModel)]="cS" name="cS" (ngModelChange)=cSChange($event) nzPlaceHolder="请选择">
       <nz-option *ngFor="let option of depList" [nzLabel]="option" [nzValue]="depList.indexOf(option)+''"></nz-option>
</nz-select>

for...of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。对象被看作是一个类数组(array-like)对象。
生成器是一个函数，它可以退出函数，稍后重新进入函数。
// generator-example.js
function* generator(){ 
  yield 1; 
  yield 2; 
  yield 3; 
}; 
for (const g of generator()) { 
  console.log(g); 
}
for in循环遍历的是数组的键值(索引)对象的属性，而for of循环遍历的是数组的值。给数组添加一个自定义属性name，并且赋值"数组"。然后进行遍历输出的，会发现新定义的属性也被for in输出来了，而for of并不会对name进行输出。

for...in 循环将遍历对象的所有可枚举属性。

//for-in-example.js
Array.prototype.newArr = () => {};
Array.prototype.anotherNewArr = () => {};
const array = ['foo', 'bar', 'baz'];
 
for (const value in array) { 
  console.log(value);
}
// Outcome:
// 0
// 1
// 2
// newArr
// anotherNewArr

for...in 不仅枚举上面的数组声明，它还从构造函数的原型中查找继承的非枚举属性，在这个例子中，newArr 和 anotherNewArr 也会打印出来。
注意：任何具有 Symbol.iterator 属性的元素都是可迭代的。
    Object.keys() --返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用for...in循环遍历该对象时返回的顺序一致

Object.keys(obj);

    Object.values() --返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同(区别在于 for-in 循环枚举原型链中的属性)

Object.values(obj);

    Object.getOwnPropertyNames() --返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组

Object.getOwnPropertyNames(obj);

// st表格
data: any[] = Array(10000)
    .fill({})
    .map((_item: any, index: number) => {
      return {
        id: index + 1,
        picture: {
          thumbnail: `https://randomuser.me/api/portraits/thumb/women/${Math.min(index + 1, 30)}.jpg`,
        },
        email: `e${index + 1}@qq.com`,
        phone: `phone - ${index + 1}`,
        price: Math.ceil(Math.random() * 10000000) + 10000000,
        registered: new Date(),
      };
    });


要使用拖曳，那必须先在module里导入
import { DragDropModule } from '@angular/cdk/drag-drop';

imports: [

DragDropModule

]

时间格式化
function dateFormat(fmt, date) {
    let ret;
    const opt = {
        "Y+": date.getFullYear().toString(),        // 年
        "m+": (date.getMonth() + 1).toString(),     // 月
        "d+": date.getDate().toString(),            // 日
        "H+": date.getHours().toString(),           // 时
        "M+": date.getMinutes().toString(),         // 分
        "S+": date.getSeconds().toString()          // 秒
        // 有其他格式化字符需求可以继续添加，必须转化成字符串
    };
    for (let k in opt) {
        ret = new RegExp("(" + k + ")").exec(fmt);
        if (ret) {
            fmt = fmt.replace(ret[1], (ret[1].length == 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, "0")))
        };
    };
    return fmt;
}
