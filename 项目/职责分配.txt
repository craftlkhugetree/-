职责分配  
src\app\routes\sys-manage\resbonsibility-management\resbonsibility-management.component.ts




// arr.forEach((item, index) => {
    //   if (item[cParentCode] === '' || item[cParentCode] === '' || item[cParentCode] === null) {
    //     // console.log(item)
    //     tree.push({
    //       title: item.cTreeName,
    //       key: item.cTreeCode,
    //       children: [],
    //     });
    //     arr.splice(index, 1);
    //   }
    // });
每次splice都会删除i，生成新数组arr，那么紧挨着的i+1就到了i的位置，而forEach不会再去i的位置了。

所以要用filter
const arrNew:any = arr.filter(item => {
      if (item[cParentCode] === '' || item[cParentCode] === '' || item[cParentCode] === null) {
            tree.push({
              title: item.cTreeName,
              key: item.cTreeCode,
              children: [],
            });
      }else{
        return item;
      }
    });

树节点递归
  getCheckedRecursive(tree: NzTreeNode[],origin:any[],change:any[]){
    tree.forEach(item => {
      origin.forEach(element => {
        if (element.cTreeCode === item.key) {
          change.push({ iMenuID: element.iTreeID, cFBIDs: '' });
        }
      });
      if (item.children && item.children.length>0){
          this.getCheckedRecursive(item.children,origin,change);
      };
    });
  }