<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>执行上下文</title>
</head>
<body>
    1.代码分类（位置）：全局代码、函数（局部）代码。<hr>
    2.在执行全局代码前将window确定为全局执行上下文，对全局数据进行预处理：<br>
    （1）var定义的全局变量==>undefined，添加为window的属性<br>
    （2）function声明的全局函数==>赋值(fun)，添加为window的方法<br>
    （3）this==>赋值(window)<hr>
    3.函数执行上下文：在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的某区域），对局部数据进行预处理<br>
    （1）形参变量==>赋值（实参）==>添加为执行上下文的属性<br>
    （2）arguments==>赋值（实参列表）==>...<br>
    （3）var定义的局部变量==>undefined==>...<br>
    （4）function声明的函数==>赋值(fun)==>...方法<br>
    （5）this==>赋值（调用函数的对象）
    <hr>
    4.执行上下文栈<br>
    （1）在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文对象；<br>
    （2）在window确定后，将其添加到栈中；<br>
    （3）在函数执行上下文创建后，压栈；<br>
    （4）在当前函数执行完后，将栈顶的对象移除，出栈；<br>
    （5）当所有代码执行完后，栈中只剩window

    <script>
        console.log(a1,window.a1)   //undefined undefined
        console.log(a2)
        console.log(this)   //window    早有准备才能提升访问
        var a1 = 3
        function a2 (){}

        function fn(a1){
            console.log(a1) //2
            console.log(a2) //undefined
            a3()            //a3()
            console.log(this)   //window
            console.log(arguments)  //伪数组(2,3)
            var a2=3
            function a3(){
                console.log('a3()')
            }
        }
        fn(2,3)

        var a = 10
        var bar = function(x){
            var b=5
            foo(x+b)
        }
        var foo = function(y){
            var c=5
            console.log(a+c+y)
        }
        bar(10) //30    栈底一定是window
    </script>
    
</body>
</html>